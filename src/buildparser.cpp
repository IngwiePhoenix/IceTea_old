/*
 * Copyright (C) 2007-2014 Xagasoft, All rights reserved.
 *
 * This file is part of the Xagasoft Build and is released under the
 * terms of the license contained in the file LICENSE.
 */
#include "buildparser.h"
#include "ast.h"
#include "build.yy.h"
#include "conditionplugger.h"

#include "bu/sio.h"
using Bu::sio;

BuildParser::BuildParser( Ast &rAst ) :
    xAst( rAst )
{
    lIncludePaths.append("./");
    StrList lConds = ConditionPlugger::getInstance().getPluginList();
    for( StrList::iterator i = lConds.begin(); i; i++ )
        hConds.insert( *i, true );
}

BuildParser::~BuildParser()
{
}

int build_parse( yyscan_t yyscanner, BuildParser &bld );

void BuildParser::load( const Bu::String &sFile )
{
    yyscan_t scanner;

    sFilename.push( sFile );
    FILE *fIn = fopen( sFile.getStr(), "rt" );
    if( fIn == NULL )
    {
        throw Bu::ExceptionBase("Cannot open file: %s", sFile.getStr() );
    }
    build_lex_init( &scanner );
    // build_set_debug( true, scanner );
    build_set_in( fIn, scanner );

    build_parse( scanner, *this );

    build_lex_destroy( scanner );
    fclose( fIn );

    // Bu::sio << xAst;
}

bool BuildParser::isKeyword( const Bu::String &sStr )
{
    if( sStr == "important" )
        return true;
    if( sStr == "normal" )
        return true;
    if( sStr == "hidden" )
        return true;
    if( sStr == "autogenerated" )
        return true;
    return false;
}

bool BuildParser::isCond( const Bu::String &sStr )
{
    try
    {
        return hConds.get( sStr );
    }
    catch(...)
    {
        return false;
    }
}

void BuildParser::include( const Bu::String &sStr, void *scanner, YYLTYPE *loc )
{
    for( StrList::iterator pi = lIncludePaths.begin(); pi; pi++ )
    {
        FILE *fIn = fopen( (*pi + sStr).getStr(), "rt" );
        if( fIn == NULL )
        {
            continue;
        }
        sFilename.push( sStr );
        sLocation.push( *loc );
        loc->first_line = loc->last_line = 1;
        loc->first_column = loc->last_column = 0;
        build_push_buffer_state(
            build__create_buffer( fIn, YY_READ_BUF_SIZE, scanner ),
            scanner
            );
        Bu::String::const_iterator i = sStr.find('/');
        if( i )
        {
            for(;;)
            {
                Bu::String::const_iterator j = i.find('/');
                if( !j )
                    break;
                i = j+1;
            }
            //sio << "Hey, found it from here:  " << sStr.getSubStr( sStr.begin(), i ) << sio.nl;
            xAst.addNode( AstNode::typePushPrefix, sStr.getSubStr( sStr.begin(), i ) );
        }
        else
        {
            xAst.addNode( AstNode::typePushPrefix, "" );
        }
        return;
    }
    Bu::String msg("Could not open include file: ");
    msg += sStr;
    error(
        loc->first_line, loc->last_line,
        loc->first_column, loc->last_column,
        msg
        );
}

void BuildParser::endInclude( YYLTYPE *loc )
{
    sFilename.pop();
    memcpy( loc, &sLocation.peek(), sizeof(YYLTYPE) );
    sLocation.pop();
    xAst.addNode( AstNode::typePopPrefix );
}

void BuildParser::error( int iLine1, int iLine2, int iCol1, int iCol2,
    const Bu::String &sMsg )
{
    throw Bu::ExceptionBase("%s: %d-%d:%d-%d: %s",
        sFilename.peek().getStr(), iLine1, iLine2, iCol1, iCol2, sMsg.getStr()
        );
}

void BuildParser::addIncludePath( const Bu::String &sPath )
{
    lIncludePaths.append( sPath + "/" );
}

