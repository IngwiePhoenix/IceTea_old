#include "buildparser.h"
#include "ast.h"
#include "build.yy.h"

#include "bu/sio.h"
using Bu::sio;

BuildParser::BuildParser( Ast &rAst ) :
	xAst( rAst )
{
	lIncludePaths.append("./");
}

BuildParser::~BuildParser()
{
}

int build_parse( yyscan_t yyscanner, BuildParser &bld );

void BuildParser::load( const Bu::FString &sFile )
{
	yyscan_t scanner;

	sFilename.push( sFile );
	FILE *fIn = fopen( sFile.getStr(), "rt" );
	build_lex_init( &scanner );
	// build_set_debug( true, scanner );
	build_set_in( fIn, scanner );

	build_parse( scanner, *this );

	build_lex_destroy( scanner );
	fclose( fIn );

	// Bu::sio << xAst;
}

bool BuildParser::isKeyword( const Bu::FString &sStr )
{
	if( sStr == "important" )
		return true;
	if( sStr == "normal" )
		return true;
	if( sStr == "hidden" )
		return true;
	if( sStr == "autogenerated" )
		return true;
	return false;
}

bool BuildParser::isCond( const Bu::FString &sStr )
{
	if( sStr == "filetime" )
		return true;
	if( sStr == "always" )
		return true;
	if( sStr == "never" )
		return true;
	return false;
}

void BuildParser::include( const Bu::FString &sStr, void *scanner, YYLTYPE *loc )
{
	for( StrList::iterator pi = lIncludePaths.begin(); pi; pi++ )
	{
		FILE *fIn = fopen( (*pi + sStr).getStr(), "rt" );
		if( fIn == NULL )
		{
			continue;
		}
		sFilename.push( sStr );
		sLocation.push( *loc );
		loc->first_line = loc->last_line = 1;
		loc->first_column = loc->last_column = 0;
		build_push_buffer_state(
			build__create_buffer( fIn, YY_READ_BUF_SIZE, scanner ),
			scanner
			);
		Bu::FString::const_iterator i = sStr.find('/');
		if( i )
		{
			for(;;)
			{
				Bu::FString::const_iterator j = i.find('/');
				if( !j )
					break;
				i = j+1;
			}
			sio << "Hey, found it from here:  " << sStr.getSubStr( sStr.begin(), i ) << sio.nl;
			xAst.addNode( AstNode::typePushPrefix, sStr.getSubStr( sStr.begin(), i ) );
		}
		else
		{
			xAst.addNode( AstNode::typePushPrefix, "" );
		}
		return;
	}
	Bu::FString msg("Could not open include file: ");
	msg += sStr;
	error(
		loc->first_line, loc->last_line,
		loc->first_column, loc->last_column,
		msg
		);
}

void BuildParser::endInclude( YYLTYPE *loc )
{
	sFilename.pop();
	memcpy( loc, &sLocation.peek(), sizeof(YYLTYPE) );
	sLocation.pop();
	xAst.addNode( AstNode::typePopPrefix );
}

void BuildParser::error( int iLine1, int iLine2, int iCol1, int iCol2,
	const Bu::FString &sMsg )
{
	throw Bu::ExceptionBase("%s: %d-%d:%d-%d: %s",
		sFilename.peek().getStr(), iLine1, iLine2, iCol1, iCol2, sMsg.getStr()
		);
}

void BuildParser::addIncludePath( const Bu::FString &sPath )
{
	lIncludePaths.append( sPath + "/" );
}

